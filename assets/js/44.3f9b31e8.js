(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{384:function(e,s,n){"use strict";n.r(s);var t=n(8),a=Object(t.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("co源码库地址："),s("a",{attrs:{href:"https://github.com/tj/co",target:"_blank",rel:"noopener noreferrer"}},[e._v("code"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("co是著名程序员"),s("a",{attrs:{href:"https://github.com/tj",target:"_blank",rel:"noopener noreferrer"}},[e._v("TJ"),s("OutboundLink")],1),e._v("的一个开源库，这个项目的初衷是解决异步回金字塔的问题。我们曾经在[后续传递(continuation)和回调(callback)的差别(https://github.com/luckyScript/blog/issues/7)中，提到过回调金字塔的优化方式，实现callcc函数，其实这种方式就是利用Thunk的方式来进行优化，Thunkify这个库工作原理也是如此。")]),e._v(" "),s("p",[e._v("我们今天谈到的co，在早起的版本也是通过这种方式来进行处理回调的问题，但是当Generator和Promise出现的时候，co便利用这两个特性很好的解决了这些问题。著名框架"),s("a",{attrs:{href:"https://github.com/koajs/koa/tree/1.4.1",target:"_blank",rel:"noopener noreferrer"}},[e._v("koa1"),s("OutboundLink")],1),e._v("便是利用了co模块作为解决异步问题的基础来实现的。")]),e._v(" "),s("blockquote",[s("p",[e._v("如果你对nodejs的异步工作原理不是很懂，建议你可以花几分钟先去了解一下，这可能更利于你理解本文的内容。")])]),e._v(" "),s("p",[e._v("要阅读源码，我们先来看看它怎么用。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("co(function* (){\n    var fileName = yield readFile('./fileName.txt', 'utf-8');\n    var fileContent = yield readFile(fileName, 'utf-8');\n    return fileContent\n}).then(console.log, console.error);\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("我们看这个代码，首先我们希望从"),s("code",[e._v("fileName.txt")]),e._v("中获取到fileName，然后再读名称为fileName这个的文件，最后返回文件内容。")]),e._v(" "),s("p",[e._v("如果不用co模块，我们写出来的代码可能是这样的：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("content = function () {\n    return readFile('./fileName.txt', 'utf-8', function (err, data) {\n        return readFile(data, 'utf-8', function (err, data) {\n            return data;\n        })\n    })\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("绕来绕去的明显不够直观。相比于co模块的用法，这种传统的代码简直会让人抓狂。")]),e._v(" "),s("p",[e._v("co模块的源码只有短短的240行。让我们就直入正题吧。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function co(gen) {\n  var ctx = this;\n  var args = slice.call(arguments, 1);\n  return new Promise(function(resolve, reject) {\n    if (typeof gen === 'function') gen = gen.call(ctx); // 如果gen是Generator，则执行\n    if (!gen || typeof gen.next !== 'function') return resolve(gen); // 如果不是函数，则直接resolve\n  ...\n  }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("co函数接收一个Generator，返回一个Promise对象。所以我们在执行完co之后，可以链式调用then的原因也是如此。")]),e._v(" "),s("h3",{attrs:{id:"自动执行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动执行"}},[e._v("#")]),e._v(" 自动执行")]),e._v(" "),s("p",[e._v("自动执行Generator是co的重要特点。我们看Promise对象的函数中，执行了"),s("code",[e._v("onFulfilled()")]),e._v("。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function onFulfilled(res) {\n      var ret;\n      try {\n        ret = gen.next(res); // 这是构造器的next方法\n      } catch (e) {\n        return reject(e);\n      }\n      next(ret); // 这个是名字为next的函数调用\n      return null;\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("可以看到这个函数调用了gen的next方法之后，调用了next()函数，gen是传入的Generator function，一般执行完gen的next方法，协程会将执行权交出。而next()函数一定就是co自动执行Generator的核心。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("    function next(ret) {\n      if (ret.done) return resolve(ret.value); // 如果gen.next已经执行完了整个构造器，那么直接resolve这个值。\n      var value = toPromise.call(ctx, ret.value); \n      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);\n      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '\n        + 'but the following object was passed: \"' + String(ret.value) + '\"'));\n    }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("可以看到next函数接收gen.next()的结果，这个结果是一个包含value和done的键值对，不在赘述。函数的第二行开始，给ret.value转化为Promise对象，然后再调用value.then(onFulfilled,onRejected)。问题来了，next函数执行完了，可是哪里调用了gen.next()呢？仔细看看onFulfilled，恩，已经讲过这个函数了。\nco通过这种递归的方式，只要gen.next()没有完成就会一直执行下去。\n而我们发现，co内部的状态管理，也是通过toPromise来构造成为Promise对象，使得能够处理好异步之间的关系。")]),e._v(" "),s("p",[e._v("我们来看看这个 toPromise方法：")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function toPromise(obj) {\n  if (!obj) return obj;\n  if (isPromise(obj)) return obj; // 如果是Promise对象直接返回\n  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj); // 如果是generator函数，用co模块来返回Promise对象\n  if ('function' == typeof obj) return thunkToPromise.call(this, obj); // Thunk函数\n  if (Array.isArray(obj)) return arrayToPromise.call(this, obj); // arrayToPromise方法\n  if (isObject(obj)) return objectToPromise.call(this, obj); //objectToPromise\n  return obj;\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function objectToPromise(obj){\n  var results = new obj.constructor();\n  var keys = Object.keys(obj);\n  var promises = [];\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var promise = toPromise.call(this, obj[key]);\n    if (promise && isPromise(promise)) defer(promise, key);\n    else results[key] = obj[key];\n  }\n  return Promise.all(promises).then(function () {\n    return results;\n  });\n\n  function defer(promise, key) {\n    // predefine the key in the result\n    results[key] = undefined;\n    promises.push(promise.then(function (res) {\n      results[key] = res;\n    }));\n  }\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br"),s("span",{staticClass:"line-number"},[e._v("16")]),s("br"),s("span",{staticClass:"line-number"},[e._v("17")]),s("br"),s("span",{staticClass:"line-number"},[e._v("18")]),s("br"),s("span",{staticClass:"line-number"},[e._v("19")]),s("br"),s("span",{staticClass:"line-number"},[e._v("20")]),s("br"),s("span",{staticClass:"line-number"},[e._v("21")]),s("br"),s("span",{staticClass:"line-number"},[e._v("22")]),s("br")])]),s("p",[e._v("我们来看看典型的objectToPromise,主要实现方法是对obj的每一个键值对执行toPromise方法，通过Promise.all异步并行，将一个promise数组里的每个promise保存到相应的key里面。\n对于co模块的解读，由于本人水平有限，有些地方可能理解的不足，还望指教。")]),e._v(" "),s("h2",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),s("p",[e._v("对于Promise，我觉得前端程序员应该都已经很熟悉了。promise拥有pending,fulfilled,rejected这几种状态，当执行了resolve或者reject之后，promise的状态会由初始的pending转化为fulfilled或者rejected。当然并不是你想的那样，resolve之后就是fulfilled的状态，当promise resolve一个reject的promise的时候，这时候就是rejected的状态。")]),e._v(" "),s("p",[e._v("同一个promise对象可以有多个then方法，这些then方法会在promise被resolve或者reject的时候，顺序调用。但是这个顺序调用的代码执行还是异步的。")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const promise = Promise.resolve(1)\npromise.then(setTimeout(()=>console.log(1), 100))\npromise.then(console.log(2));\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("这段代码的输出为 2 1")]),e._v(" "),s("p",[e._v("Promise的then方法也可以链式调用，因为then方法本身返回一个新的Promise对象，且之前的onFulfilled或onRejected执行后返回值会作为下一个then方法的onFulfilled对象传入。")]),e._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[e._v("promise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("v")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'first'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" v"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("这段代码输出为2 1\n可见.then方法的链式调用也是异步的，那么我们如何才能让其执行了前一个再执行后一个呢？\n答案不是很明显么，用Promise或者可以返回then方法的实例")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 返回值为promise的实例\nPromise.resolve(1)\n  .then(v=> new Promise((resolve, reject)=>{\n    setTimeout(()=> resolve(v+3), 3000);\n  }))\n  .then(v=>console.log(v)); //三秒后输出 4\n\n// 返回值为含有then方法的对象\nPromise.resolve(1)\n  .then(v=>({\n    then(resolve, reject){\n      setTimeout(()=> resolve(v+2), 2000);\n    }\n  }))\n  .then(v=> console.log(v)); //二秒后输出 3\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br"),s("span",{staticClass:"line-number"},[e._v("15")]),s("br")])])])}),[],!1,null,null,null);s.default=a.exports}}]);