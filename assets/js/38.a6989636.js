(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{378:function(n,s,a){"use strict";a.r(s);var t=a(8),e=Object(t.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[n._v("#")]),n._v(" 前言")]),n._v(" "),s("p",[n._v("在绝大多数的编程语言中，函数通常返回值给调用它的对象。举个例子:")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var sum = add(2, 3);\nconsole.log(sum);\nfunction add(x, y) {\n    return x + y;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br")])]),s("p",[n._v("然而，在现在很多的“函数是一等公民”的语言（函数式编程语言）中，我们也可以把值返回给回调函数，而不是直接返回给调用的那个对象。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("add(2, 3, function (sum) {\n    console.log(sum);\n});\nfunction add(x, y, cont) {\n    cont(x + y);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br")])]),s("p",[n._v("上面的例子可以看出，我们并没有把参数运行后的值返回，而是将它传递给了cont，而cont也就是调用时的那个函数。我们称cont是add的一个传递。")]),n._v(" "),s("p",[n._v("相信大家对回调非常熟悉吧，对于后续传递风格，或许只是喜欢函数式编程的小伙伴可能了解过。那么回调与后续传递的差别是什么呢？")]),n._v(" "),s("h2",{attrs:{id:"中语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#中语"}},[n._v("#")]),n._v(" 中语")]),n._v(" "),s("p",[n._v("我认为后续传递是回调的一种特殊的形式。一个函数可以有许多个回调函数，许多次回调：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var array = [1, 2, 3];\nforEach(array, function (element, array, index) {\n    array[index] = 2 * element;\n});\nfunction forEach(array, callback) {\n    var length = array.length;\n    for (var i = 0; i < length; i++)\n        callback(array[i], array, i);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br")])]),s("p",[n._v("当一个函数做的最后一件事情是回调另一个函数的时候，我们称第二个函数为第一个函数的后续传递。e.g:")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var array = [1, 2, 3];\nforEach(array, function (element, array, index) {\n    array[index] = 2 * element;\n});\nfunction forEach(array, callback) {\n    var length = array.length;\n    // last thing forEach does\n    // cont is a continuation of forEach\n    cont(0);\n    function cont(index) {\n        if (index < length) {\n            callback(array[index], array, index);\n            // last thing cont does\n            // cont is a continuation of itself\n            cont(++index);\n        }\n    }\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br")])]),s("p",[n._v("如果当一个函数的最后一件是是调用另一个函数的时候，我们称这种情况叫做尾调用（参考尾递归#2 ）。一些解释器，比如Scheme语言的解释器会对尾调用进行优化。这样不会导致函数的堆积（比如斐波那契的运算），而将状态层层传递。")]),n._v(" "),s("h2",{attrs:{id:"后话"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#后话"}},[n._v("#")]),n._v(" 后话")]),n._v(" "),s("p",[n._v("如果想继续了解后续传递风格请往下读")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("alert(pythagoras(3, 4));\nfunction pythagoras(x, y) {\n    return x * x + y * y;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br")])]),s("p",[n._v("如果我们将每一种运算，包括加减乘除都写成函数的形式（在函数式编程中，运算符就是函数）。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("alert(pythagoras(3, 4));\nfunction pythagoras(x, y) {\n    return add(square(x), square(y));\n}\nfunction square(x) {\n    return multiply(x, x);\n}\nfunction multiply(x, y) {\n    return x * y;\n}\nfunction add(x, y) {\n    return x + y;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br")])]),s("p",[n._v("如果我们不允许返回任何值，我们可以利用后续传递风格来重新改下代码：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("pythagoras(3, 4, alert);\nfunction pythagoras(x, y, cont) {\n    square(x, function (x_squared) {\n        square(y, function (y_squared) {\n            add(x_squared, y_squared, cont);\n        });\n    });\n}\nfunction square(x, cont) {\n    multiply(x, x, cont);\n}\nfunction multiply(x, y, cont) {\n    cont(x * y);\n}\nfunction add(x, y, cont) {\n    cont(x + y);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br")])]),s("p",[n._v("(面目狰狞，仿佛又看到了node的魔鬼金字塔)")]),n._v(" "),s("p",[n._v("不允许返回任何值，所以你不得不吧这些值或者状态传到下一个函数里面。这种风格叫做后续传递风格(continuation passing style)。\n不过仍然存在两个问题需要考虑。")]),n._v(" "),s("p",[n._v("这种风格明显增加了调用栈的大小需求，如果你没有用Scheme或者支持尾调用优化的语言去写代码，很容易就会栈溢出（我也不知道容易不容易。。。）\n魔鬼金字塔。\n当然，第一个问题其实是好解决的，因为js支持异步编程。异步调用的结果就是，当你调用传递函数的时候，前面的状态已经计算好了。这样就导致堆栈大小并不会增加。")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("Function.prototype.async = async;\npythagoras.async(3, 4, alert);\nfunction pythagoras(x, y, cont) {\n    square.async(x, function (x_squared) {\n        square.async(y, function (y_squared) {\n            add.async(x_squared, y_squared, cont);\n        });\n    });\n}\nfunction square(x, cont) {\n    multiply.async(x, x, cont);\n}\nfunction multiply(x, y, cont) {\n    cont.async(x * y);\n}\nfunction add(x, y, cont) {\n    cont.async(x + y);\n}\nfunction async() {\n    //use js setTimeout to implement async\n    setTimeout.bind(null, this, 0).apply(null, arguments);\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br")])]),s("p",[n._v("解决第二个问题的方法通常是利用一个函数callcc，全称是call-with-current-continuation，可惜的是callcc并没有在js里完整的实现。所以我们重写一下")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("pythagoras(3, 4, alert);\nfunction pythagoras(x, y, cont) {\n    var x_squared = callcc(square.bind(null, x));\n    var y_squared = callcc(square.bind(null, y));\n    add(x_squared, y_squared, cont);\n}\nfunction square(x, cont) {\n    multiply(x, x, cont);\n}\nfunction multiply(x, y, cont) {\n    cont(x * y);\n}\nfunction add(x, y, cont) {\n    cont(x + y);\n}\nfunction callcc(f) {\n    var cc = function (x) {\n        cc = x;\n    };\n    f(cc);\n    return cc;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br")])])])}),[],!1,null,null,null);s.default=e.exports}}]);